"""
embed_web.py - PlatformIO pre-build script

Reads web/index.html (unified HTML with section markers), web/css/styles.css,
and web/js/app.js, then generates the 6 PROGMEM header files that
WebHandlers.cpp streams to the client.

Section markers in index.html (<!-- @EMBED:NAME -->) split the HTML into
regions. Even-numbered sections map 1:1 to PROGMEM arrays; odd-numbered
sections are dev-only (CSS <link>, mock CFG, <script src>) and are skipped.

Source layout:
    web/index.html      →  HEAD / BODY / INPUTS / FOOTER sections
    web/css/styles.css   →  CSS_STYLES  (wrapped in <style>…</style>)
    web/js/app.js        →  HTML_SCRIPT (wrapped in <script>…</script></body></html>)

Usage:
    extra_scripts = pre:embed_web.py      (automatic via PlatformIO)
    python embed_web.py                   (standalone / manual)
"""

import os
import re
import sys


# ── Section splitter ────────────────────────────────────────────────────

# Regex matching <!-- @EMBED:WORD --> lines (including trailing newline).
_MARKER_RE = re.compile(r"^<!-- @EMBED:\w+ -->$\n?", re.MULTILINE)

# Which split-index maps to which PROGMEM header.
# Odd indices (1, 5) are dev-only and intentionally absent here.
SECTION_MAP = {
    0: {  # before <!-- @EMBED:STYLES -->
        "dst": "src/WebContentHead.h",
        "var": "HTML_HEAD",
        "comment": "Section 1: HTML Head (scripts, meta tags)",
    },
    2: {  # between <!-- @EMBED:BODY --> and <!-- @EMBED:INPUTS -->
        "dst": "src/WebContentBody.h",
        "var": "HTML_BODY_START",
        "comment": "Section 2: Body start (static content before input fields)",
    },
    3: {  # between <!-- @EMBED:INPUTS --> and <!-- @EMBED:FOOTER -->
        "dst": "src/WebContentInputs.h",
        "var": "HTML_INPUTS",
        "comment": "Section 3: Dynamic input fields with placeholders",
    },
    4: {  # between <!-- @EMBED:FOOTER --> and <!-- @EMBED:CONFIG -->
        "dst": "src/WebContentFooter.h",
        "var": "HTML_FOOTER",
        "comment": "Section 4: Footer with version placeholder",
    },
}

# Standalone file → PROGMEM header (with prefix/suffix wrapping).
FILE_MAP = [
    {
        "src": "web/css/styles.css",
        "dst": "src/styles.h",
        "var": "CSS_STYLES",
        "prefix": "<style>\n",
        "suffix": "\n</style>",
        "comment": "CSS styles — auto-generated from web/css/styles.css",
    },
    {
        "src": "web/js/app.js",
        "dst": "src/WebContentScript.h",
        "var": "HTML_SCRIPT",
        "prefix": "  <script>\n",
        "suffix": "\n  </script>\n</body>\n</html>",
        "comment": "Section 5: JavaScript and closing HTML tags",
    },
]


# ── Header generator ────────────────────────────────────────────────────

def generate_header(var_name, content, comment):
    """Build a complete PROGMEM header file string."""
    return (
        "#pragma once\n"
        "#include <Arduino.h>\n"
        "\n"
        "// ============================================================================\n"
        f"// {comment}\n"
        "// AUTO-GENERATED by embed_web.py from web/ sources — do not edit manually!\n"
        "// ============================================================================\n"
        "\n"
        f'const char {var_name}[] PROGMEM = R"rawliteral(\n'
        f"{content}\n"
        ')rawliteral";\n'
    )


def write_if_changed(dst_path, header):
    """Write header file only when content differs (avoids rebuild triggers)."""
    if os.path.exists(dst_path):
        with open(dst_path, "r", encoding="utf-8") as f:
            if f.read() == header:
                return False
    with open(dst_path, "w", encoding="utf-8") as f:
        f.write(header)
    return True


# ── Main logic ──────────────────────────────────────────────────────────

def embed_web_files(project_dir):
    """Parse web/ sources and generate PROGMEM headers in src/."""
    web_dir = os.path.join(project_dir, "web")
    index_path = os.path.join(web_dir, "index.html")

    if not os.path.exists(index_path):
        print("  [embed_web] ERROR: web/index.html not found!")
        return

    # Read and split index.html at section markers
    with open(index_path, "r", encoding="utf-8") as f:
        index_content = f.read()

    sections = _MARKER_RE.split(index_content)
    expected = 7  # 6 markers → 7 sections (indices 0-6)
    if len(sections) != expected:
        print(
            f"  [embed_web] ERROR: Expected {expected} sections in index.html, "
            f"found {len(sections)}. Check <!-- @EMBED:XXX --> markers."
        )
        return

    updated = 0
    skipped = 0

    # ── Generate headers from index.html sections ───────────────────
    for idx, cfg in SECTION_MAP.items():
        content = sections[idx]
        dst_path = os.path.join(project_dir, cfg["dst"])
        header = generate_header(cfg["var"], content, cfg["comment"])
        if write_if_changed(dst_path, header):
            updated += 1
            print(f"  [embed_web] index.html[{idx}] -> {cfg['dst']}")
        else:
            skipped += 1

    # ── Generate headers from standalone CSS / JS files ─────────────
    for m in FILE_MAP:
        src_path = os.path.join(project_dir, m["src"])
        dst_path = os.path.join(project_dir, m["dst"])

        if not os.path.exists(src_path):
            print(f"  [embed_web] SKIP  {m['src']} (not found)")
            skipped += 1
            continue

        with open(src_path, "r", encoding="utf-8") as f:
            content = f.read()

        full_content = m["prefix"] + content + m["suffix"]
        header = generate_header(m["var"], full_content, m["comment"])

        if write_if_changed(dst_path, header):
            updated += 1
            print(f"  [embed_web] {m['src']:25s} -> {m['dst']}")
        else:
            skipped += 1

    # ── Summary ─────────────────────────────────────────────────────
    if updated:
        print(f"  [embed_web] {updated} file(s) updated, {skipped} unchanged")
    else:
        print(f"  [embed_web] All {skipped} web files up to date")


# ── PlatformIO integration ──────────────────────────────────────────────

try:
    Import("env")  # type: ignore  # noqa: F821

    def pre_build_hook(source, target, env):
        project_dir = env.get("PROJECT_DIR", os.getcwd())
        embed_web_files(project_dir)

    env.AddPreAction("buildprog", pre_build_hook)  # type: ignore  # noqa: F821

except Exception:
    # Standalone execution
    if __name__ == "__main__":
        project_dir = os.path.dirname(os.path.abspath(__file__))
        print(f"[embed_web] Standalone mode, project dir: {project_dir}")
        embed_web_files(project_dir)
